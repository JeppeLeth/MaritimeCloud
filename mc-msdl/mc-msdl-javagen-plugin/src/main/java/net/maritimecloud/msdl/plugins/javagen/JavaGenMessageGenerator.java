/* Copyright (c) 2011 Danish Maritime Authority.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.maritimecloud.msdl.plugins.javagen;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;

import net.maritimecloud.core.message.Message;
import net.maritimecloud.core.message.MessageParser;
import net.maritimecloud.core.message.MessageSerializers;
import net.maritimecloud.core.message.MessageWriter;
import net.maritimecloud.internal.util.Hashing;
import net.maritimecloud.msdl.model.BaseMessage;
import net.maritimecloud.msdl.model.FieldDeclaration;
import net.maritimecloud.msdl.model.type.ListOrSetType;
import net.maritimecloud.msdl.model.type.MSDLBaseType;
import net.maritimecloud.msdl.model.type.MapType;
import net.maritimecloud.msdl.parser.antlr.StringUtil;

import org.cakeframework.internal.codegen.CodegenClass;
import org.cakeframework.internal.codegen.CodegenMethod;

/**
 *
 * @author Kasper Nielsen
 */
public class JavaGenMessageGenerator {
    final CodegenClass c = new CodegenClass();

    final CodegenClass parent;

    final BaseMessage msg;

    final List<FieldDeclaration> fields;

    JavaGenMessageGenerator(CodegenClass parent, BaseMessage msg) {
        this.parent = parent;
        this.msg = msg;
        fields = msg.getFields();
    }

    void generateClass() {
        c.addImport(Message.class);

        if (parent == null) {
            c.setDefinition("public class ", msg.getName(), " implements ", Message.class, "<", msg.getName(), ">");
        } else {
            c.setDefinition("public static class ", msg.getName(), " implements ", Message.class, "<", msg.getName(),
                    ">");
        }
        c.addImport(MessageParser.class);
        c.addFieldWithJavadoc("A message parser that can create new instances of this class.", "public static final ",
                MessageParser.class, "<", msg.getName(), "> PARSER = new Parser();");
    }

    final JavaGenMessageGenerator generate() {
        generateClass();
        generateFields();
        generateConstructor();
        generateHashCode();
        generateEquals();
        generateWriteTo();
        generateAccessors();
        generateTo();
        new JavaGenMessageParserGenerator(this).generateParser();
        new JavaGenMessageImmutableGenerator(this).generate();
        return this;
    }

    void generateConstructor() {
        // We only generate constructors if we have at least one field, otherwise we rely on default constructors
        // generated by javac
        if (fields.size() > 0) {
            CodegenMethod m = c.newMethod("public ", c.getSimpleName(), "()");

            m.addJavadoc("Creates a new ", c.getSimpleName(), ".");
            // TODO Vi laver ikke deep cloning
            m = c.newMethod(c.getSimpleName(), "(", c.getSimpleName(), " copyFrom)");
            m.addJavadoc("Creates a new ", c.getSimpleName(), " by copying an existing.");
            m.addJavadocParameter("copyFrom", "the instance to copy all fields from");
            for (FieldDeclaration f : msg) {
                m.add("this.", f.getName(), " = copyFrom." + f.getName(), ";");
            }
        }
    }

    void generateFields() {
        for (FieldDeclaration f : fields) {
            JavaGenType ty = new JavaGenType(f.getType());
            ty.addImports(c);
            String init = "";
            MSDLBaseType t = f.getType().getBaseType();
            if (t == MSDLBaseType.LIST) {
                init = " = new java.util.ArrayList<>()";
            } else if (t == MSDLBaseType.LIST) {
                init = " = new java.util.LinkedHashSet<>()";
            } else if (t == MSDLBaseType.MAP) {
                init = " = new java.util.LinkedHashMap<>()";
            }
            c.addFieldWithJavadoc("Hey", ty.render(), " ", f.getName(), init, ";");
        }
    }

    void generateHashCode() {
        CodegenMethod m = c.newMethod("public int hashCode()");
        m.addAnnotation(Override.class).addJavadoc("{@inheritDoc}");
        if (fields.size() == 0) {
            m.add("return ", c.getSimpleName().hashCode(), " ;");
        } else if (fields.size() == 1) {
            m.add("return ", generateHashCode(fields.get(0)), ";");
        } else {
            m.add("int result = 31 + ", generateHashCode(fields.get(0)), ";");
            for (int i = 1; i < fields.size() - 1; i++) {
                m.add("result = 31 * result + ", generateHashCode(fields.get(i)), ";");
            }
            m.add("return 31 * result + ", generateHashCode(fields.get(fields.size() - 1)), ";");
        }
    }

    String generateHashCode(FieldDeclaration f) {
        if (f.getType().getBaseType() == MSDLBaseType.INT32) {
            return f.getName();
        } else {
            c.addImport(Hashing.class);
            return "Hashing.hashcode(this." + f.getName() + ")";
        }
    }

    void generateTo() {
        c.addImport(MessageSerializers.class);
        CodegenMethod m = c.newMethod("public String toJSON()");
        m.addJavadoc("Returns a JSON representation of this message");
        m.add("return ", MessageSerializers.class, ".writeToJSON(this);");
    }

    void generateEquals() {
        CodegenMethod m = c.newMethod("public boolean equals(Object other)");
        m.addJavadoc("{@inheritDoc}").addAnnotation(Override.class);
        m.add("if (other == this) {");
        m.add("return true;");
        m.add("} else if (other instanceof ", c.getSimpleName(), ") {");
        if (fields.size() == 0) {
            m.add("return true");
        } else {
            m.add(c.getSimpleName(), " o = (", c.getSimpleName(), ") other;");
            for (int i = 0; i < fields.size(); i++) {
                StringBuilder b = i == 0 ? new StringBuilder("return ") : new StringBuilder("       ");
                FieldDeclaration f = fields.get(i);
                // JavaGenType t = new JavaGenType(f.getType());
                // Check data typen
                // if (false /* fields.get(i).getType().getBaseType().isPrimitive() */) {
                // b.append("this." + f.getName() + " == o." + f.getName());
                // } else {
                c.addImport(Objects.class);
                b.append("Objects.equals(" + f.getName() + ", o." + f.getName() + ")");
                // }
                b.append(i == fields.size() - 1 ? ";" : " &&");
                m.add(b);
            }
        }
        m.add("}");
        m.add("return false;");
    }

    void generateWriteTo() {
        CodegenMethod m = c.newMethod("public void writeTo(", MessageWriter.class, " w) throws IOException");
        m.addAnnotation(Override.class).addJavadoc("{@inheritDoc}");
        m.addImport(IOException.class).addImport(MessageWriter.class);
        for (FieldDeclaration f : fields) {
            m.add("w.write", new JavaGenType(f.getType()).writeReadName(), "(", f.getTag(), ", \"", f.getName(),
                    "\", ", f.getName(), ");");
        }
    }


    void generateAccessors() {
        for (FieldDeclaration f : fields) {
            String beanPrefix = StringUtil.capitalizeFirstLetter(f.getName());
            MSDLBaseType t = f.getType().getBaseType();
            JavaGenType los = new JavaGenType(f.getType());
            String r = los.render();

            // Getter


            // GETTER
            CodegenMethod get = c.newMethod("public ", r, " get", beanPrefix, "()");
            if (f.getComment().getMain() != null) {
                get.addJavadoc("Returns " + f.getComment().getMainUncapitalized());
            }
            // if (f.getComment() != null && f.getComment().getCommentUncapitalized() != null) {
            // get.addJavadoc("Returns " + f.getComment().getCommentUncapitalized());
            // }
            if (t.isComplexType()) {
                String type = StringUtil.capitalizeFirstLetter(t.name().toLowerCase());
                get.add("return java.util.Collections.unmodifiable", type, "(", f.getName(), ");");
            } else {
                get.add("return ", f.getName(), ";");
            }
            // HAS
            CodegenMethod has = c.newMethod("public boolean has", beanPrefix, "()");
            has.add("return ", f.getName(), " != null;");

            // SETTER
            CodegenMethod set;
            if (t == MSDLBaseType.LIST || t == MSDLBaseType.SET) {
                String name = StringUtil.removePlural(f.getName());
                set = generateComplexAccessor(c, f);
                set.addImport(Objects.class);
                set.add("java.util.Objects.requireNonNull(", name, ", \"", name, " is null\");");
                set.add("this.", f.getName(), ".add(", name, ");");
            } else if (t == MSDLBaseType.MAP) {
                set = generateComplexAccessor(c, f);
                set.add("java.util.Objects.requireNonNull(key, \"key is null\");");
                set.add("java.util.Objects.requireNonNull(value, \"value is null\");");
                set.add("this.", f.getName(), ".put(key, value);");
            } else {
                set = c.newMethod("public ", c.getSimpleName(), " set", beanPrefix, "(", r, " ", f.getName(), ")");
                set.add("this.", f.getName(), " = ", f.getName(), ";");
            }

            // if (f.getComment() != null && f.getComment().getCommentUncapitalized() != null) {
            // m.addJavadoc("Returns " + f.getComment().getCommentUncapitalized());
            // }
            // m.add("return ", f.getName(), ";");
            //
            //


            // public SomeTest putMd(Integer key, Map<List<SomeTest>, String> value) {
            // Map<List<SomeTest>, String> $value = new HashMap<>();
            // for (Map.Entry<List<SomeTest>, String> $e : value.entrySet()) {
            // List<SomeTest> $res = new ArrayList<>();
            // for (SomeTest $st : $e.getKey()) {
            // $res.add(requireNonNull($st));
            // }
            // if (!$res.isEmpty()) {
            // $value.put($res, requireNonNull($e.getValue()));
            // }
            // }
            //
            // return this;
            // }
            //
            // public SomeTest putMpd(Integer key, List<SomeTest> value) {
            // java.util.Objects.requireNonNull(key, "key is null");
            // java.util.Objects.requireNonNull(value, "value is null");
            // List<SomeTest> $res = new ArrayList<>();
            // for (SomeTest $st : value) {
            // $res.add(requireNonNull($st));
            // }
            // if (!$res.isEmpty()) {
            // this.mpd.put(key, $res);
            // } else {
            // this.mpd.remove(key);
            // }
            // return this;
            // }
            set.add("return this;");
        }
    }

    CodegenMethod generateComplexAccessor(CodegenClass clazz, FieldDeclaration f) {
        String name = StringUtil.removePlural(f.getName());
        String beanPrefix2 = StringUtil.capitalizeFirstLetter(name);
        if (f.getType().getBaseType() == MSDLBaseType.MAP) {
            JavaGenType key = new JavaGenType(((MapType) f.getType()).getKeyType());
            JavaGenType value = new JavaGenType(((MapType) f.getType()).getValueType());
            return clazz.newMethod("public ", c.getSimpleName(), " put", beanPrefix2, "(", key.render(), " key, ",
                    value.render(), " value)");
        } else {
            JavaGenType element = new JavaGenType(((ListOrSetType) f.getType()).getElementType());
            return clazz.newMethod("public ", c.getSimpleName(), " add", beanPrefix2, "(", element.render(), " ", name,
                    ")");
        }
    }


    static class NameGenerator {
        private final HashMap<String, Integer> map = new HashMap<>();

        String next(String prefix) {
            Integer val = map.get(prefix);
            map.put(prefix, val == null ? 1 : val + 1);
            return "$" + prefix + (val == null ? "" : val);
        }
    }
}
