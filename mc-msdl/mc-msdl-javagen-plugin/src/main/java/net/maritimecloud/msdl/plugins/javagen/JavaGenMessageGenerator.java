/* Copyright (c) 2011 Danish Maritime Authority.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.maritimecloud.msdl.plugins.javagen;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;

import net.maritimecloud.core.message.Message;
import net.maritimecloud.core.message.MessageParser;
import net.maritimecloud.core.message.MessageReader;
import net.maritimecloud.core.message.MessageSerializers;
import net.maritimecloud.core.message.MessageWriter;
import net.maritimecloud.core.message.ValueParser;
import net.maritimecloud.internal.message.util.Hashing;
import net.maritimecloud.internal.message.util.MessageHelper;
import net.maritimecloud.msdl.model.BaseMessage;
import net.maritimecloud.msdl.model.BaseType;
import net.maritimecloud.msdl.model.FieldDeclaration;
import net.maritimecloud.msdl.model.ListOrSetType;
import net.maritimecloud.msdl.model.MapType;
import net.maritimecloud.msdl.model.Type;
import net.maritimecloud.msdl.parser.antlr.StringUtil;
import net.maritimecloud.msdl.plugins.javagen.annotation.JavaImplements;
import net.maritimecloud.net.broadcast.BroadcastMessage;

import org.cakeframework.internal.codegen.CodegenClass;
import org.cakeframework.internal.codegen.CodegenMethod;

/**
 *
 * @author Kasper Nielsen
 */
public class JavaGenMessageGenerator {
    final CodegenClass c;

    final CodegenClass parent;

    final BaseMessage msg;

    final List<FieldDeclaration> fields;

    JavaGenMessageGenerator(CodegenClass parent, BaseMessage msg) {
        this.parent = parent;
        this.msg = msg;
        fields = msg.getFields();
        this.c = parent == null ? new CodegenClass() : parent.addInnerClass();
    }

    void generateClass() {
        Class<?> mType = this instanceof JavaGenBroadcastMessageGenerator ? BroadcastMessage.class : Message.class;
        String imple = "";
        if (msg.isAnnotationPresent(JavaImplements.class)) {
            for (String s : msg.getAnnotation(JavaImplements.class).value()) {
                imple += ", " + s;
            }
        }
        c.addImport(mType);
        if (parent == null) {
            c.setDefinition("public class ", msg.getName(), " implements ", mType, imple);// "<", msg.getName(), ">");
        } else {
            c.setDefinition("public static class ", msg.getName(), " implements ", mType, imple);// , "<",
            // msg.getName(), ">");
        }
        c.addImport(MessageParser.class);
        c.addFieldWithJavadoc("A message parser that can create new instances of this class.", "public static final ",
                MessageParser.class, "<", msg.getName(), "> PARSER = new Parser();");
    }

    JavaGenMessageGenerator generate() {
        generateClass();
        generateFields();
        // We only generate constructors if we have at least one field, otherwise we rely on default constructors
        // generated by javac
        if (fields.size() > 0) {
            generateConstructorEmpty();
            generateConstructorParser();
            generateConstructorImmutable();
        }
        generateHashCode();
        generateEquals();
        generateWriteTo(c, fields);
        generateAccessors();
        generateToFrom();
        JavaGenMessageParserGenerator.generateParser(this);
        new JavaGenMessageImmutableGenerator(this).generate();
        return this;
    }

    void generateConstructorEmpty() {
        CodegenMethod m = c.addMethod("public ", c.getSimpleName(), "()");
        m.addJavadoc("Creates a new ", c.getSimpleName(), ".");
        for (FieldDeclaration f : fields) {
            BaseType t = f.getType().getBaseType();
            if (t == BaseType.LIST) {
                m.add(f.getName(), " = new java.util.ArrayList<>();");
            } else if (t == BaseType.SET) {
                m.add(f.getName(), " = new java.util.LinkedHashSet<>();");
            } else if (t == BaseType.MAP) {
                m.add(f.getName(), " = new java.util.LinkedHashMap<>();");
            }
        }
    }

    void generateConstructorParser() {
        CodegenMethod m = c.addMethod(c.getSimpleName(), "(", MessageReader.class, " reader) throws IOException");
        m.addJavadoc("Creates a new ", c.getSimpleName(), " by reading from a message reader.");
        m.addJavadocParameter("reader", "the message reader");
        for (FieldDeclaration f : fields) {
            BaseType type = f.getType().getBaseType();
            if (type.isPrimitive()) {
                String s = StringUtil.capitalizeFirstLetter(type.name().toLowerCase());
                m.add("this.", f.getName(), " = reader.read", s, "(", f.getTag(), ", \"", f.getName(), "\", null);");
            } else if (type == BaseType.ENUM) {
                JavaGenType ty = new JavaGenType(f.getType());
                m.add("this.", f.getName(), " = reader.readEnum(", f.getTag(), ", \"", f.getName(), "\", ",
                        ty.render(), ".PARSER);");
            } else if (type == BaseType.MESSAGE) {
                JavaGenType ty = new JavaGenType(f.getType());
                m.add("this.", f.getName(), " = reader.readMessage(", f.getTag(), ", \"", f.getName(), "\", ",
                        ty.render(), ".PARSER);");
            } else if (type == BaseType.LIST) { // Complex type
                ListOrSetType los = (ListOrSetType) f.getType();
                m.add("this.", f.getName(), " = ", MessageHelper.class, ".readList(reader, ", f.getTag(), ", \"",
                        f.getName(), "\", ", complexParser(los.getElementType()), ");");
            } else if (type == BaseType.SET) { // Complex type
                ListOrSetType los = (ListOrSetType) f.getType();
                m.add("this.", f.getName(), " = ", MessageHelper.class, ".readSet(reader, ", f.getTag(), ", \"",
                        f.getName(), "\", ", complexParser(los.getElementType()), ");");
            } else { // Complex type
                MapType los = (MapType) f.getType();
                m.add("this.", f.getName(), " = ", MessageHelper.class, ".readMap(reader, ", f.getTag(), ", \"",
                        f.getName(), "\", ", complexParser(los.getKeyType()), ", ", complexParser(los.getValueType()),
                        ");");
            }

            // if (f.getType() .isMessage()) {
            // m.add("instance.", f.getName(), " = ", f.getMSDLBaseType().getRefType(), ".PARSER.parse(reader);");
            // }
        }
    }

    void generateConstructorImmutable() {
        CodegenMethod m = c.addMethod(c.getSimpleName(), "(", c.getSimpleName(), " instance)");
        m.addJavadoc("Creates a new ", c.getSimpleName(), " by copying an existing.");
        m.addJavadocParameter("instance", "the instance to copy all fields from");
        for (FieldDeclaration f : fields) {
            BaseType t = f.getType().getBaseType();
            if (t == BaseType.LIST || t == BaseType.SET || t == BaseType.MAP) {
                c.addImport(MessageHelper.class);
                m.add("this.", f.getName(), " = ", MessageHelper.class, ".immutableCopy(instance." + f.getName(), ");");
            } else if (t == BaseType.MESSAGE) {
                c.addImport(MessageHelper.class);
                m.add("this.", f.getName(), " = ", MessageHelper.class, ".immutable(instance." + f.getName(), ");");
            } else {
                m.add("this.", f.getName(), " = instance." + f.getName(), ";");
            }
        }


        // TODO Vi laver ikke deep cloning
        //
        // for (FieldDeclaration f : msg) {
        // MSDLBaseType t = f.getType().getBaseType();
        // if (t == MSDLBaseType.MAP) {
        // m.add("this.", f.getName(), ".putAll(copyFrom." + f.getName(), ");");
        // } else if (t == MSDLBaseType.SET || t == MSDLBaseType.LIST) {
        // m.add("this.", f.getName(), ".addAll(copyFrom." + f.getName(), ");");
        // } else {
        // m.add("this.", f.getName(), " = copyFrom." + f.getName(), ";");
        // }
        // }
    }


    String complexParser(Type type) {
        BaseType b = type.getBaseType();
        if (b.isPrimitive()) {
            c.addImport(ValueParser.class);
            return ValueParser.class.getSimpleName() + "." + b.name().toUpperCase();
        } else if (b.isReferenceType()) {
            JavaGenType ty = new JavaGenType(type);
            return ty.render() + ".PARSER";
        } else if (b == BaseType.LIST) {
            ListOrSetType los = (ListOrSetType) type;
            return complexParser(los.getElementType()) + ".listOf()";
        } else if (b == BaseType.SET) {
            ListOrSetType los = (ListOrSetType) type;
            return complexParser(los.getElementType()) + ".setOf()";
        } else {
            MapType los = (MapType) type;
            return "MessageParser.ofMap(" + complexParser(los.getKeyType()) + ", " + complexParser(los.getValueType())
                    + ")";
        }
    }

    void generateFields() {
        for (FieldDeclaration f : fields) {
            JavaGenType ty = new JavaGenType(f.getType());
            ty.addImports(c);
            String init = "private " + (f.getType().getBaseType().isComplexType() ? "final " : "");
            // MSDLBaseType t = f.getType().getBaseType();
            // if (t == MSDLBaseType.LIST) {
            // init = " = new java.util.ArrayList<>()";
            // } else if (t == MSDLBaseType.SET) {
            // init = " = new java.util.LinkedHashSet<>()";
            // } else if (t == MSDLBaseType.MAP) {
            // init = " = new java.util.LinkedHashMap<>()";
            // }
            c.addFieldWithJavadoc("Hey", init, ty.render(), " ", f.getName(), ";");
        }
    }

    void generateHashCode() {
        CodegenMethod m = c.addMethod("public int hashCode()");
        m.addAnnotation(Override.class).addJavadoc("{@inheritDoc}");
        if (fields.size() == 0) {
            m.add("return ", c.getSimpleName().hashCode(), " ;");
        } else if (fields.size() == 1) {
            m.add("return ", generateHashCode(fields.get(0)), ";");
        } else {
            m.add("int result = 31 + ", generateHashCode(fields.get(0)), ";");
            for (int i = 1; i < fields.size() - 1; i++) {
                m.add("result = 31 * result + ", generateHashCode(fields.get(i)), ";");
            }
            m.add("return 31 * result + ", generateHashCode(fields.get(fields.size() - 1)), ";");
        }
    }

    String generateHashCode(FieldDeclaration f) {
        // if (f.getType().getBaseType() == MSDLBaseType.INT32) {
        // return f.getName();
        // } else {
        c.addImport(Hashing.class);
        return "Hashing.hashcode(this." + f.getName() + ")";
        // }
    }

    void generateToFrom() {
        c.addImport(MessageSerializers.class);
        CodegenMethod m = c.addMethod("public String toJSON()");
        m.addJavadoc("Returns a JSON representation of this message");
        m.add("return ", MessageSerializers.class, ".writeToJSON(this);");

        CodegenMethod from = c.addMethod("public static ", c.getSimpleName(), " fromJSON(", CharSequence.class, " c)");
        from.addJavadoc("Creates a message of this type from a JSON throwing a runtime exception if the format of the message does not match");
        from.add("return ", MessageSerializers.class, ".readFromJSON(PARSER, c);");
    }

    //
    // public static HelloWorld fromJSON(CharSequence c) {
    // return MessageSerializers.readFromJSON(PARSER, c);
    // }

    void generateEquals() {
        CodegenMethod m = c.addMethod("public boolean equals(Object other)");
        m.addJavadoc("{@inheritDoc}").addAnnotation(Override.class);
        m.add("if (other == this) {");
        m.add("return true;");
        m.add("} else if (other instanceof ", c.getSimpleName(), ") {");
        if (fields.size() == 0) {
            m.add("return true");
        } else {
            m.add(c.getSimpleName(), " o = (", c.getSimpleName(), ") other;");
            for (int i = 0; i < fields.size(); i++) {
                StringBuilder b = i == 0 ? new StringBuilder("return ") : new StringBuilder("       ");
                FieldDeclaration f = fields.get(i);
                // JavaGenType t = new JavaGenType(f.getType());
                // Check data typen
                // if (false /* fields.get(i).getType().getBaseType().isPrimitive() */) {
                // b.append("this." + f.getName() + " == o." + f.getName());
                // } else {
                c.addImport(Objects.class);
                b.append("Objects.equals(" + f.getName() + ", o." + f.getName() + ")");
                // }
                b.append(i == fields.size() - 1 ? ";" : " &&");
                m.add(b);
            }
        }
        m.add("}");
        m.add("return false;");
    }

    static void generateWriteTo(CodegenClass c, Iterable<FieldDeclaration> fields) {
        CodegenMethod m = c.addMethod("public void writeTo(", MessageWriter.class, " w) throws IOException");
        m.addAnnotation(Override.class).addJavadoc("{@inheritDoc}");
        m.addImport(IOException.class).addImport(MessageWriter.class);
        for (FieldDeclaration f : fields) {
            m.add("w.write", new JavaGenType(f.getType()).writeReadName(), "(", f.getTag(), ", \"", f.getName(),
                    "\", ", f.getName(), ");");
        }
    }


    void generateAccessors() {
        for (FieldDeclaration f : fields) {
            String beanPrefix = StringUtil.capitalizeFirstLetter(f.getName());
            BaseType t = f.getType().getBaseType();
            JavaGenType los = new JavaGenType(f.getType());
            String r = los.render();

            // Getter


            // GETTER
            CodegenMethod get = c.addMethod("public ", r, " get", beanPrefix, "()");
            if (f.getComment().getMain() != null) {
                get.addJavadoc("Returns " + f.getComment().getMainUncapitalized());
            }
            // if (f.getComment() != null && f.getComment().getCommentUncapitalized() != null) {
            // get.addJavadoc("Returns " + f.getComment().getCommentUncapitalized());
            // }
            if (t.isComplexType()) {
                String type = StringUtil.capitalizeFirstLetter(t.name().toLowerCase());
                get.add("return java.util.Collections.unmodifiable", type, "(", f.getName(), ");");
            } else {
                get.add("return ", f.getName(), ";");
            }
            // HAS
            CodegenMethod has = c.addMethod("public boolean has", beanPrefix, "()");
            has.add("return ", f.getName(), " != null;");

            // SETTER
            CodegenMethod set;
            if (t == BaseType.LIST || t == BaseType.SET) {
                String name = StringUtil.removePlural(f.getName());
                set = generateComplexAccessor(c, f);
                set.addImport(Objects.class);
                set.add("java.util.Objects.requireNonNull(", name, ", \"", name, " is null\");");
                set.add("this.", f.getName(), ".add(", name, ");");
            } else if (t == BaseType.MAP) {
                set = generateComplexAccessor(c, f);
                set.add("java.util.Objects.requireNonNull(key, \"key is null\");");
                set.add("java.util.Objects.requireNonNull(value, \"value is null\");");
                set.add("this.", f.getName(), ".put(key, value);");
            } else {
                set = c.addMethod("public ", c.getSimpleName(), " set", beanPrefix, "(", r, " ", f.getName(), ")");
                set.add("this.", f.getName(), " = ", f.getName(), ";");
            }

            // if (f.getComment() != null && f.getComment().getCommentUncapitalized() != null) {
            // m.addJavadoc("Returns " + f.getComment().getCommentUncapitalized());
            // }
            // m.add("return ", f.getName(), ";");
            //
            //


            // public SomeTest putMd(Integer key, Map<List<SomeTest>, String> value) {
            // Map<List<SomeTest>, String> $value = new HashMap<>();
            // for (Map.Entry<List<SomeTest>, String> $e : value.entrySet()) {
            // List<SomeTest> $res = new ArrayList<>();
            // for (SomeTest $st : $e.getKey()) {
            // $res.add(requireNonNull($st));
            // }
            // if (!$res.isEmpty()) {
            // $value.put($res, requireNonNull($e.getValue()));
            // }
            // }
            //
            // return this;
            // }
            //
            // public SomeTest putMpd(Integer key, List<SomeTest> value) {
            // java.util.Objects.requireNonNull(key, "key is null");
            // java.util.Objects.requireNonNull(value, "value is null");
            // List<SomeTest> $res = new ArrayList<>();
            // for (SomeTest $st : value) {
            // $res.add(requireNonNull($st));
            // }
            // if (!$res.isEmpty()) {
            // this.mpd.put(key, $res);
            // } else {
            // this.mpd.remove(key);
            // }
            // return this;
            // }
            set.add("return this;");
        }
    }

    CodegenMethod generateComplexAccessor(CodegenClass clazz, FieldDeclaration f) {
        String name = StringUtil.removePlural(f.getName());
        String beanPrefix2 = StringUtil.capitalizeFirstLetter(name);
        if (f.getType().getBaseType() == BaseType.MAP) {
            JavaGenType key = new JavaGenType(((MapType) f.getType()).getKeyType());
            JavaGenType value = new JavaGenType(((MapType) f.getType()).getValueType());
            return clazz.addMethod("public ", c.getSimpleName(), " put", beanPrefix2, "(", key.render(), " key, ",
                    value.render(), " value)");
        } else {
            JavaGenType element = new JavaGenType(((ListOrSetType) f.getType()).getElementType());
            return clazz.addMethod("public ", c.getSimpleName(), " add", beanPrefix2, "(", element.render(), " ", name,
                    ")");
        }
    }


    static class NameGenerator {
        private final HashMap<String, Integer> map = new HashMap<>();

        String next(String prefix) {
            Integer val = map.get(prefix);
            map.put(prefix, val == null ? 1 : val + 1);
            return "$" + prefix + (val == null ? "" : val);
        }
    }
}
