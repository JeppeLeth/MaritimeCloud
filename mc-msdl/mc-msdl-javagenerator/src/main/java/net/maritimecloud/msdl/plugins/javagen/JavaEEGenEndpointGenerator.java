/* Copyright (c) 2011 Danish Maritime Authority.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.maritimecloud.msdl.plugins.javagen;

import net.maritimecloud.msdl.model.EndpointDefinition;
import net.maritimecloud.msdl.model.EndpointMethod;
import net.maritimecloud.msdl.model.FieldOrParameter;
import net.maritimecloud.msdl.model.MsdlFile;
import net.maritimecloud.net.MessageHeader;
import org.cakeframework.internal.codegen.CodegenBlock;
import org.cakeframework.internal.codegen.CodegenClass;
import org.cakeframework.internal.codegen.CodegenMethod;

import java.util.List;

import static java.util.Objects.requireNonNull;

/**
 * Generates EJB classes for MSDL endpoints
 */
public class JavaEEGenEndpointGenerator {

    final CodegenClass cEJB;

    final EndpointDefinition ed;

    final MsdlFile file;

    final List<EndpointMethod> functions;

    final CodegenClass parent;

    final JavaGenPlugin plugin;

    /** Constructor */
    JavaEEGenEndpointGenerator(JavaGenPlugin plugin, CodegenClass parent, EndpointDefinition ed) {
        this.parent = parent;
        this.ed = ed;
        this.functions = ed.getFunctions();
        this.cEJB = new CodegenClass();
        this.file = ed.getFile();
        this.plugin = requireNonNull(plugin);
    }

    /** Generates the EJB classes */
    JavaEEGenEndpointGenerator generate() {
        generateEJB();
        return this;
    }

    /** Generates the EJB class for the endpoint definition */
    void generateEJB() {
        String msdlClassName = "Abstract" + ed.getName();
        String ejbClassName = msdlClassName + "Bean";

        cEJB.addImport(MessageHeader.class);
        cEJB.addImport("javax.annotation.PostConstruct");
        cEJB.addImport("javax.inject.Inject");
        cEJB.addImport("net.maritimecloud.mms.jee.MmsClientService");

        cEJB.addJavadoc("Auto-generated by the MSDL maven plug-in.<p/>\n",
                " * Base class for Singleton implementation of the ", msdlClassName, " MMS service.<p/>\n",
                " * Concrete implementation should be annotated with @Singleton and @Startup annotations to \n",
                " * ensure that the service is registered properly upon start-up");
        cEJB.setDefinition("public abstract class ", ejbClassName, " extends ", msdlClassName);

        cEJB.addFieldWithJavadoc("The MMS Client Service.", "@Inject\n    protected MmsClientService mmsClientService;");

        CodegenMethod rm = cEJB.addMethod("public void registerService()")
                .addAnnotation("@PostConstruct")
                .addJavadoc("Called when the Singleton is instantiated. Register the MMS service");
        rm.add("final Class<? extends ", ejbClassName, "> ejbClass = getClass();");
        CodegenBlock b = rm.newNestedBlock("if (!ejbClass.isAnnotationPresent(javax.ejb.Singleton.class) &&\n" +
                "                !ejbClass.isAnnotationPresent(javax.inject.Singleton.class))");
        b.add("throw new RuntimeException(\"The \" + ejbClass + \" must be a @Singleton\");");

        rm.add("mmsClientService.endpointRegister(new ", msdlClassName, "() {");
        for (EndpointMethod f : functions) {
            rm.add("@Override");
            rm.add(generateSignature(cEJB, f, true), "{");
            rm.add(generateSignature(cEJB, f, false), ";");
            rm.add("}");
        }
        rm.add("});");
    }

    /**
     * Generate the specified method as either a declaration or invocation
     * @param cc the codegen class
     * @param f the method to generate
     * @param declaration whether to generate a declaration or an invocation
     * @return the method signature
     */
    String generateSignature(CodegenClass cc, EndpointMethod f, boolean declaration) {
        StringBuilder sb = new StringBuilder();
        if (declaration) {
            sb.append("protected ");
            sb.append(type(cc, f)).append(" ");
        } else {
            if (f.getReturnType() != null) {
                sb.append("return ");
            }
            sb.append("MmsClientService.getMmsServiceBean(ejbClass).");
        }

        sb.append(f.getName()).append("(");

        if (declaration) {
            sb.append("MessageHeader ");
        }
        sb.append("header");

        for (FieldOrParameter d : f.getParameters()) {
            sb.append(", ");
            if (declaration) {
                sb.append(new JavaGenType(d.getType()).render(cc, file)).append(" ");
            }
            sb.append(d.getName());
        }
        sb.append(")");
        return sb.toString();
    }

    /** Generates the return type of the method */
    String type(CodegenClass cc, EndpointMethod f) {
        String s;
        if (f.getReturnType() == null) {
            s = "void";
        } else {
            JavaGenType los = new JavaGenType(f.getReturnType());
            s = los.render(cc, file);
        }
        return s;
    }
}
