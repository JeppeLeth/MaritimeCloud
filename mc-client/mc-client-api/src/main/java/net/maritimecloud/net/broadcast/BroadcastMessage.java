/* Copyright (c) 2011 Danish Maritime Authority.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.maritimecloud.net.broadcast;

import net.maritimecloud.core.message.Message;
import net.maritimecloud.core.message.MessageSerializers;


/**
 * Abstract class for a message that can be broadcast.
 * <p>
 * Normally, there should be no need to manually extend this class. As subclasses of it are auto generated by MSDL
 * files.
 *
 * @author Kasper Nielsen
 */
/**
 * Abstract class for a message that can be broadcast.
 * <p>
 * Any implementation of this message must contain a <tt>public static final String CHANNEL = "name"</tt> field.
 * Initialized to a unique channel that the broadcast is send via.
 *
 * @author Kasper Nielsen
 */
public interface BroadcastMessage extends Message {

    /**
     * Returns the broadcast channel on which the broadcast is sent. Defaults (for now) to the name of the class.
     *
     * @return the broadcast channel on which the message should be sent
     */
    default String channel() {
        return getClass().getName();
    }

    default BroadcastMessage immutable() {
        return this;
    }

    default String toJSON() {
        return MessageSerializers.writeToJSON(this);
    }
}

// static final ConcurrentHashMap<String, Class<? extends BroadcastMessage>> CACHE = new ConcurrentHashMap<>();

// static ServiceLoader<BroadcastMessage> sl = ServiceLoader.load(BroadcastMessage.class);

// /**
// * Finds the broadcast message for the specified channel.
// *
// * @param channel
// * the name of the channel
// * @return the corresponding to the specified channel
// */
// public static Class<? extends BroadcastMessage> findClass(String channel) {
// requireNonNull("channel is null");
// for (BroadcastMessage m : sl) {
// if (getChannelField(m.getClass()).equals("channel")) {
// return m.getClass();
// }
// }
// return null;
// }
//
// public static String findChannelForMessageType(Class<? extends BroadcastMessage> type) {
// String channel = getChannelField(type);
//
// return channel;
// }
//
// static String getChannelField(Class<? extends BroadcastMessage> type) {
// Field f;
// try {
// f = type.getField("CHANNEL");
// } catch (NoSuchFieldException e) {
// throw new RuntimeException("No field named CHANNEL found on " + type.getCanonicalName(), e);
// }
// if (!Modifier.isFinal(f.getModifiers())) {
// throw new RuntimeException("Field named CHANNEL on " + type.getCanonicalName() + " must be final");
// } else if (!Modifier.isStatic(f.getModifiers())) {
// throw new RuntimeException("Field named CHANNEL on " + type.getCanonicalName() + " must be static");
// } else if (!Modifier.isPublic(f.getModifiers())) {
// throw new RuntimeException("Field named CHANNEL on " + type.getCanonicalName() + " must be public");
// } else if (f.getType() != String.class) {
// throw new RuntimeException("Field named CHANNEL on " + type.getCanonicalName()
// + " must be of a String type");
// }
// try {
// return (String) f.get(null);
// } catch (IllegalArgumentException e) {
// throw new Error("oops, should never happen since the field is a string", e);
// } catch (IllegalAccessException e) {
// throw new Error("oops, should never happen since the field is public", e);
// }
// }
// }
